<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Dessiner ton ≈ìuvre</title>
<style>
  body {
    background: #f0f0f0;
    font-family: Arial, sans-serif;
    padding: 1rem;
    text-align: center;
    -webkit-user-select:none;
    -moz-user-select:none;
    -ms-user-select:none;
    user-select:none;
  }
  canvas {
    border: 2px solid #333;
    background-color: #fff;
    touch-action: none;
    cursor: crosshair;
    display: block;
    margin: auto;
  }
  .tools {
    margin-top: 1rem;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    align-items: center;
  }
  .tools input[type="color"],
  .tools input[type="range"],
  .tools input[type="file"],
  .tools input[type="number"] {
    vertical-align: middle;
  }
  #title {
    width: 80%;
    padding: 0.5rem;
    margin-top: 1rem;
    font-size: 1rem;
  }
  button, label {
    user-select: none;
  }
  button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    cursor: pointer;
    border: none;
    border-radius: 6px;
    background: #4a90e2;
    color: white;
  }
  button:hover {
    background: #357ac9;
  }
  #modeToggle {
    background: #ff9800;
  }
  #modeToggle.active {
    background: #388e3c;
  }
  #brushSizeDisplay {
    display: inline-block;
    min-width: 40px;
    font-weight: bold;
    margin-left: 5px;
  }
</style>
</head>
<body>
  <h1>üñåÔ∏è Cr√©e ton ≈ìuvre</h1>

  <input type="text" id="title" placeholder="Titre de l'≈ìuvre (optionnel)" />

  <div class="tools">
    <label>Mode :
      <button id="modeToggle" class="active">Dessin</button>
    </label>

    <label>Couleur:
      <input type="color" id="colorPicker" value="#000000" />
    </label>

    <label>Taille:
      <input type="range" id="sizePicker" min="0.1" max="100" step="0.1" value="5" />
      <input type="number" id="sizeNumber" min="0.1" max="100" step="0.1" value="5" style="width:60px;" />
      <span id="brushSizeDisplay">5 px</span>
    </label>

    <label>Fond:
      <input type="color" id="bgColorPicker" value="#ffffff" />
    </label>

    <label>Image de fond:
      <input type="file" id="bgImagePicker" accept="image/*" />
    </label>

    <button id="removeBgBtn" title="Supprimer l'image de fond">‚ùå</button>
    <button id="undoBtn" title="Annuler dernier trait">‚Ü©Ô∏è</button>
    <button id="clearBtn" title="Effacer tout">üßΩ</button>
    <button id="screenshotBtn" title="T√©l√©charger">üì•</button>
  </div>

  <canvas id="drawCanvas" width="350" height="350"></canvas>

<script>
const canvas = document.getElementById("drawCanvas");
const ctx = canvas.getContext("2d");

const colorPicker = document.getElementById("colorPicker");
const sizePicker = document.getElementById("sizePicker");
const sizeNumber = document.getElementById("sizeNumber");
const brushSizeDisplay = document.getElementById("brushSizeDisplay");
const clearBtn = document.getElementById("clearBtn");
const undoBtn = document.getElementById("undoBtn");
const screenshotBtn = document.getElementById("screenshotBtn");
const titleInput = document.getElementById("title");
const bgColorPicker = document.getElementById("bgColorPicker");
const bgImagePicker = document.getElementById("bgImagePicker");
const removeBgBtn = document.getElementById("removeBgBtn");
const modeToggle = document.getElementById("modeToggle");

let painting = false;
let paths = [];
let currentPath = [];

let bgColor = "#ffffff";
let bgImage = null;

let scale = 1;
let offsetX = 0;
let offsetY = 0;
let lastDist = null;
let lastMidpoint = null;
let isPanning = false;
let mode = "draw";
let texts = [];

let selectedTextIndex = null;
let isDraggingText = false;
let lastTouchOrMouse = null;

function clampOffsets() {
  const widthScaled = canvas.width * scale;
  const heightScaled = canvas.height * scale;

  offsetX = widthScaled > canvas.width ? Math.min(0, Math.max(offsetX, canvas.width - widthScaled)) : 0;
  offsetY = heightScaled > canvas.height ? Math.min(0, Math.max(offsetY, canvas.height - heightScaled)) : 0;
}

function screenToCanvas(x, y) {
  return { x: (x - offsetX) / scale, y: (y - offsetY) / scale };
}

function drawBackground(ctxTarget) {
  ctxTarget.fillStyle = bgColor;
  ctxTarget.fillRect(0, 0, canvas.width, canvas.height);
  if (bgImage) ctxTarget.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
}

function redrawCanvas() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);
  drawBackground(ctx);

  for (const path of paths) {
    ctx.beginPath();
    ctx.globalCompositeOperation = 'source-over';
    for (let i = 0; i < path.length; i++) {
      const point = path[i];
      ctx.lineWidth = point.size;
      ctx.strokeStyle = point.color;
      ctx.shadowBlur = 0;
      ctx.shadowColor = "transparent";
      if (i === 0) ctx.moveTo(point.x, point.y);
      else ctx.lineTo(point.x, point.y);
      ctx.stroke();
    }
  }

  for (let i = 0; i < texts.length; i++) {
    const t = texts[i];
    ctx.fillStyle = t.color;
    ctx.font = `${t.size}px sans-serif`;
    ctx.fillText(t.text, t.x, t.y);

    if (i === selectedTextIndex) {
      const width = ctx.measureText(t.text).width;
      const height = t.size;
      ctx.strokeStyle = "red";
      ctx.lineWidth = 1;
      ctx.strokeRect(t.x, t.y - height, width, height);
    }
  }

  ctx.globalCompositeOperation = 'source-over';
  ctx.beginPath();
}

function startDraw(e) {
  if (mode !== "draw") return;
  if (e.touches && e.touches.length > 1) return;
  e.preventDefault();
  painting = true;
  currentPath = [];
  ctx.beginPath();
  draw(e);
}

function draw(e) {
  if (!painting) return;
  e.preventDefault();
  let clientX = e.touches ? e.touches[0].clientX : e.clientX;
  let clientY = e.touches ? e.touches[0].clientY : e.clientY;
  const rect = canvas.getBoundingClientRect();
  const pos = screenToCanvas(clientX - rect.left, clientY - rect.top);

  ctx.lineWidth = sizePicker.value;
  ctx.lineCap = "round";
  ctx.globalCompositeOperation = 'source-over';
  ctx.strokeStyle = colorPicker.value;
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";

  ctx.lineTo(pos.x, pos.y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);

  currentPath.push({ x: pos.x, y: pos.y, color: ctx.strokeStyle, size: ctx.lineWidth });
}

function endDraw(e) {
  if (!painting) return;
  painting = false;
  ctx.beginPath();
  if (currentPath.length) paths.push([...currentPath]);
}

function getTextAtPosition(pos) {
  for (let i = texts.length - 1; i >= 0; i--) {
    const t = texts[i];
    ctx.font = `${t.size}px sans-serif`;
    const width = ctx.measureText(t.text).width;
    const height = t.size;
    if (pos.x >= t.x && pos.x <= t.x + width && pos.y <= t.y && pos.y >= t.y - height) return i;
  }
  return null;
}

canvas.addEventListener("mousedown", (e) => {
  if (mode === "draw") return startDraw(e);
  if (mode === "pan") {
    const rect = canvas.getBoundingClientRect();
    const pos = screenToCanvas(e.clientX - rect.left, e.clientY - rect.top);
    const index = getTextAtPosition(pos);
    if (index !== null) {
      selectedTextIndex = index;
      isDraggingText = true;
      lastTouchOrMouse = pos;
      redrawCanvas();
    } else {
      selectedTextIndex = null;
      redrawCanvas();
    }
  }
});

canvas.addEventListener("mousemove", (e) => {
  if (mode === "draw") return draw(e);
  if (mode === "pan" && isDraggingText && selectedTextIndex !== null) {
    const rect = canvas.getBoundingClientRect();
    const pos = screenToCanvas(e.clientX - rect.left, e.clientY - rect.top);
    const dx = pos.x - lastTouchOrMouse.x;
    const dy = pos.y - lastTouchOrMouse.y;
    texts[selectedTextIndex].x += dx;
    texts[selectedTextIndex].y += dy;
    lastTouchOrMouse = pos;
    redrawCanvas();
  }
});

canvas.addEventListener("mouseup", () => {
  if (mode === "draw") endDraw();
  isDraggingText = false;
});

modeToggle.addEventListener("click", () => {
  mode = mode === "draw" ? "pan" : mode === "pan" ? "text" : "draw";
  modeToggle.textContent = mode === "draw" ? "Dessin" : mode === "pan" ? "Navigation" : "Texte";
  modeToggle.classList.toggle("active", mode === "draw");
  canvas.style.cursor = mode === "draw" ? "crosshair" : mode === "text" ? "text" : "grab";
  painting = false;
  selectedTextIndex = null;
  redrawCanvas();
});

canvas.addEventListener("click", (e) => {
  if (mode !== "text") return;
  const rect = canvas.getBoundingClientRect();
  const pos = screenToCanvas(e.clientX - rect.left, e.clientY - rect.top);
  const text = prompt("Texte √† ajouter :");
  if (text) {
    texts.push({
      text: text,
      x: pos.x,
      y: pos.y,
      color: colorPicker.value,
      size: parseFloat(sizePicker.value)
    });
    redrawCanvas();
  }
});

bgColorPicker.addEventListener("input", e => { bgColor = e.target.value; redrawCanvas(); });
bgImagePicker.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => { bgImage = img; redrawCanvas(); };
  img.src = URL.createObjectURL(file);
});
removeBgBtn.addEventListener("click", () => { bgImage = null; bgImagePicker.value = null; redrawCanvas(); });

canvas.addEventListener("touchstart", (e) => {
  if (mode === "draw") {
    if (e.touches.length === 1) startDraw(e);
  } else if (mode === "pan") {
    if (e.touches.length === 1) {
      const rect = canvas.getBoundingClientRect();
      const pos = screenToCanvas(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
      const index = getTextAtPosition(pos);
      if (index !== null) {
        selectedTextIndex = index;
        isDraggingText = true;
        lastTouchOrMouse = pos;
        redrawCanvas();
      } else {
        selectedTextIndex = null;
        redrawCanvas();
      }
    } else if (e.touches.length === 2) {
      // pinch zoom start
      isPanning = false;
      lastDist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      lastMidpoint = {
        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
        y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
      };
    }
  }
});

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if (mode === "draw") {
    if (e.touches.length === 1) draw(e);
  } else if (mode === "pan") {
    if (isDraggingText && e.touches.length === 1 && selectedTextIndex !== null) {
      const rect = canvas.getBoundingClientRect();
      const pos = screenToCanvas(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
      const dx = pos.x - lastTouchOrMouse.x;
      const dy = pos.y - lastTouchOrMouse.y;
      texts[selectedTextIndex].x += dx;
      texts[selectedTextIndex].y += dy;
      lastTouchOrMouse = pos;
      redrawCanvas();
    } else if (e.touches.length === 2) {
      // pinch zoom move
      const dist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      const midpoint = {
        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
        y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
      };
      if (lastDist) {
        const deltaScale = dist / lastDist;
        const prevScale = scale;
        scale *= deltaScale;
        scale = Math.min(Math.max(scale, 1), 75);
        // adjust offset to zoom towards midpoint
        offsetX = midpoint.x - ((midpoint.x - offsetX) * (scale / prevScale));
        offsetY = midpoint.y - ((midpoint.y - offsetY) * (scale / prevScale));
        clampOffsets();
        redrawCanvas();
      }
      lastDist = dist;
      lastMidpoint = midpoint;
    }
  }
}, { passive: false });

canvas.addEventListener("touchend", (e) => {
  if (mode === "draw") endDraw(e);
  if (mode === "pan") {
    if (e.touches.length === 0) {
      isDraggingText = false;
      lastDist = null;
      lastMidpoint = null;
    }
  }
});

undoBtn.addEventListener("click", () => {
  if (paths.length > 0) {
    paths.pop();
    redrawCanvas();
  }
});

clearBtn.addEventListener("click", () => {
  paths = [];
  texts = [];
  redrawCanvas();
});

sizePicker.addEventListener("input", e => {
  sizeNumber.value = e.target.value;
  brushSizeDisplay.textContent = `${e.target.value} px`;
});
sizeNumber.addEventListener("input", e => {
  let val = e.target.value;
  if (val < 0.1) val = 0.1;
  else if (val > 100) val = 100;
  sizePicker.value = val;
  brushSizeDisplay.textContent = `${val} px`;
});

screenshotBtn.addEventListener("click", () => {
  // create temp canvas to render full res without pan/zoom
  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = canvas.width;
  tempCanvas.height = canvas.height;
  const tempCtx = tempCanvas.getContext("2d");

  drawBackground(tempCtx);

  for (const path of paths) {
    tempCtx.beginPath();
    for (let i = 0; i < path.length; i++) {
      const p = path[i];
      tempCtx.lineWidth = p.size;
      tempCtx.strokeStyle = p.color;
      if (i === 0) tempCtx.moveTo(p.x, p.y);
      else tempCtx.lineTo(p.x, p.y);
      tempCtx.stroke();
    }
  }

  for (const t of texts) {
    tempCtx.fillStyle = t.color;
    tempCtx.font = `${t.size}px sans-serif`;
    tempCtx.fillText(t.text, t.x, t.y);
  }

  const image = tempCanvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = image;
  a.download = (titleInput.value ? titleInput.value : "dessin") + ".png";
  a.click();
});

window.addEventListener("resize", () => {
  // Adjust canvas size on window resize if needed
  // Optionally implement responsive scaling here
});

window.onload = () => {
  redrawCanvas();
};
</script>
</body>
</html>
