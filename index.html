<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Dessiner ton ≈ìuvre</title>
<style>
  body {
    background: #f0f0f0;
    font-family: Arial, sans-serif;
    padding: 1rem;
    text-align: center;
    -webkit-user-select:none;
    -moz-user-select:none;
    -ms-user-select:none;
    user-select:none;
    margin: 0;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  h1 {
    margin-bottom: 0.5rem;
  }
  #title {
    width: 80%;
    padding: 0.5rem;
    margin: 0.5rem auto 1rem auto;
    font-size: 1rem;
    border-radius: 6px;
    border: 1px solid #ccc;
    box-sizing: border-box;
  }
  .tools {
    margin-top: 0.5rem;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    align-items: center;
    user-select: none;
  }
  .tools label {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.9rem;
  }
  .tools input[type="color"],
  .tools input[type="range"],
  .tools input[type="file"],
  .tools input[type="number"] {
    vertical-align: middle;
    cursor: pointer;
  }
  button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    cursor: pointer;
    border: none;
    border-radius: 6px;
    background: #4a90e2;
    color: white;
    transition: background 0.2s ease;
  }
  button:hover {
    background: #357ac9;
  }
  #modeToggle {
    background: #ff9800;
  }
  #modeToggle.active {
    background: #388e3c;
  }
  #brushSizeDisplay {
    display: inline-block;
    min-width: 40px;
    font-weight: bold;
    margin-left: 5px;
  }
  #drawCanvas {
    border: 2px solid #333;
    background-color: #fff;
    touch-action: none;
    cursor: crosshair;
    display: block;
    margin: 1rem auto 0 auto;
    max-width: 90vw;
    max-height: 70vh;
    box-sizing: border-box;
  }
  @media (max-width: 600px) {
    .tools {
      flex-direction: column;
      gap: 8px;
    }
    button, input[type="number"], input[type="range"] {
      width: 90vw;
      max-width: 350px;
    }
    #title {
      width: 90vw;
    }
  }
</style>
</head>
<body>
  <h1>üñåÔ∏è Cr√©e ton ≈ìuvre</h1>

  <input type="text" id="title" placeholder="Titre de l'≈ìuvre (optionnel)" />

  <div class="tools" role="region" aria-label="Outils de dessin et texte">
    <label for="modeToggle">Mode :
      <button id="modeToggle" class="active" aria-pressed="true" aria-label="Changer le mode entre dessin, navigation et texte">Dessin</button>
    </label>

    <label for="colorPicker">Couleur :
      <input type="color" id="colorPicker" value="#000000" aria-label="S√©lecteur de couleur" />
    </label>

    <label for="sizePicker">Taille :
      <input type="range" id="sizePicker" min="0.1" max="100" step="0.1" value="5" aria-valuemin="0.1" aria-valuemax="100" aria-valuenow="5" aria-label="Taille du pinceau ou texte" />
      <input type="number" id="sizeNumber" min="0.1" max="100" step="0.1" value="5" style="width:60px;" aria-label="Taille du pinceau ou texte en nombre" />
      <span id="brushSizeDisplay" aria-live="polite">5 px</span>
    </label>

    <label for="bgColorPicker">Fond :
      <input type="color" id="bgColorPicker" value="#ffffff" aria-label="S√©lecteur de couleur de fond" />
    </label>

    <label for="bgImagePicker">Image de fond :
      <input type="file" id="bgImagePicker" accept="image/*" aria-label="Choisir une image de fond" />
    </label>

    <button id="removeBgBtn" title="Supprimer l'image de fond" aria-label="Supprimer l'image de fond">‚ùå</button>
    <button id="undoBtn" title="Annuler dernier trait" aria-label="Annuler dernier trait dessin√©">‚Ü©Ô∏è</button>
    <button id="clearBtn" title="Effacer tout" aria-label="Effacer tout le dessin et texte">üßΩ</button>
    <button id="screenshotBtn" title="T√©l√©charger" aria-label="T√©l√©charger l'image finale">üì•</button>
  </div>

  <canvas id="drawCanvas" width="600" height="600" role="img" aria-label="Zone de dessin interactive"></canvas>

<script>
(() => {
  "use strict";

  // R√©cup√©ration des √©l√©ments DOM
  const canvas = document.getElementById("drawCanvas");
  const ctx = canvas.getContext("2d");

  const colorPicker = document.getElementById("colorPicker");
  const sizePicker = document.getElementById("sizePicker");
  const sizeNumber = document.getElementById("sizeNumber");
  const brushSizeDisplay = document.getElementById("brushSizeDisplay");
  const clearBtn = document.getElementById("clearBtn");
  const undoBtn = document.getElementById("undoBtn");
  const screenshotBtn = document.getElementById("screenshotBtn");
  const titleInput = document.getElementById("title");
  const bgColorPicker = document.getElementById("bgColorPicker");
  const bgImagePicker = document.getElementById("bgImagePicker");
  const removeBgBtn = document.getElementById("removeBgBtn");
  const modeToggle = document.getElementById("modeToggle");

  // Variables √©tat dessin
  let painting = false;
  let paths = [];
  let currentPath = [];

  // Fond et zoom/pan
  let bgColor = "#ffffff";
  let bgImage = null;

  let scale = 1;
  let offsetX = 0;
  let offsetY = 0;
  let lastDist = null;
  let lastMidpoint = null;
  let isPanning = false;

  // Mode : draw, pan (navigation), text
  let mode = "draw";

  // Gestion des textes : tableau d'objets {text, x, y, color, size}
  let texts = [];

  // Texte s√©lectionn√© + drag
  let selectedTextIndex = null;
  let isDraggingText = false;
  let lastTouchOrMouse = null;

  /**
   * Contraint offsetX et offsetY pour √©viter de sortir des limites
   */
  function clampOffsets() {
    const widthScaled = canvas.width * scale;
    const heightScaled = canvas.height * scale;

    offsetX = widthScaled > canvas.width ? Math.min(0, Math.max(offsetX, canvas.width - widthScaled)) : 0;
    offsetY = heightScaled > canvas.height ? Math.min(0, Math.max(offsetY, canvas.height - heightScaled)) : 0;
  }

  /**
   * Convertit coordonn√©es √©cran en coordonn√©es canvas selon scale et offset
   * @param {number} x 
   * @param {number} y 
   * @returns {{x:number,y:number}}
   */
  function screenToCanvas(x, y) {
    return { x: (x - offsetX) / scale, y: (y - offsetY) / scale };
  }

  /**
   * Dessine le fond (couleur + image si pr√©sente)
   * @param {CanvasRenderingContext2D} ctxTarget 
   */
  function drawBackground(ctxTarget) {
    ctxTarget.fillStyle = bgColor;
    ctxTarget.fillRect(0, 0, canvas.width, canvas.height);
    if (bgImage) ctxTarget.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
  }

  /**
   * Redessine tout : fond, paths, textes
   */
  function redraw() {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform pour fond
    drawBackground(ctx);
    ctx.restore();

    // Appliquer zoom & pan
    ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

    // Dessiner chemins
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    for (const path of paths) {
      if (path.length < 2) continue;
      ctx.strokeStyle = path.color;
      ctx.lineWidth = path.size;
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();
    }

    // Dessiner chemin en cours
    if (currentPath.length > 1) {
      ctx.strokeStyle = colorPicker.value;
      ctx.lineWidth = parseFloat(sizePicker.value);
      ctx.beginPath();
      ctx.moveTo(currentPath[0].x, currentPath[0].y);
      for (let i = 1; i < currentPath.length; i++) {
        ctx.lineTo(currentPath[i].x, currentPath[i].y);
      }
      ctx.stroke();
    }

    // Dessiner textes
    for (let i = 0; i < texts.length; i++) {
      const t = texts[i];
      ctx.font = `${t.size}px Arial, sans-serif`;
      ctx.fillStyle = t.color;
      ctx.textBaseline = "top";
      ctx.fillText(t.text, t.x, t.y);
      if (i === selectedTextIndex) {
        // Surbrillance texte s√©lectionn√©
        const width = ctx.measureText(t.text).width;
        ctx.strokeStyle = "rgba(0,0,255,0.7)";
        ctx.lineWidth = 2 / scale;
        ctx.strokeRect(t.x - 4 / scale, t.y - 2 / scale, width + 8 / scale, t.size + 4 / scale);
      }
    }
  }

  /**
   * Commence le dessin d'un chemin
   */
  function startDrawing(x, y) {
    if (mode !== "draw") return;
    painting = true;
    currentPath = [{ x, y }];
  }

  /**
   * Continue le dessin d'un chemin
   */
  function drawLine(x, y) {
    if (!painting) return;
    currentPath.push({ x, y });
    redraw();
  }

  /**
   * Termine le dessin d'un chemin
   */
  function endDrawing() {
    if (!painting) return;
    painting = false;
    if (currentPath.length > 1) {
      const pathObj = {
        color: colorPicker.value,
        size: parseFloat(sizePicker.value),
        ... // fixed: paths is array of arrays of points; now storing object with color, size, and points
      };
      // Correction : stocker chaque path comme un objet {color, size, points: [...]}
      pathObj.points = [...currentPath];
      paths.push(pathObj);
    }
    currentPath = [];
    redraw();
  }

  /**
   * Cherche un texte sous la position donn√©e (canvas coords)
   * Retourne l‚Äôindex ou null
   */
  function findTextAtPos(x, y) {
    for (let i = texts.length - 1; i >= 0; i--) {
      const t = texts[i];
      ctx.font = `${t.size}px Arial, sans-serif`;
      const width = ctx.measureText(t.text).width;
      const height = t.size;
      if (
        x >= t.x && x <= t.x + width &&
        y >= t.y && y <= t.y + height
      ) return i;
    }
    return null;
  }

  /**
   * Ajoute un nouveau texte √† la position donn√©e (canvas coords)
   */
  function addTextAtPos(x, y) {
    const textContent = prompt("Entrez le texte √† ajouter :", "");
    if (!textContent) return;
    texts.push({
      text: textContent,
      x,
      y,
      color: colorPicker.value,
      size: parseFloat(sizePicker.value),
    });
    selectedTextIndex = texts.length - 1;
    redraw();
  }

  /**
   * Mise √† jour de l‚Äôaffichage de la taille
   */
  function updateSizeDisplay(value) {
    brushSizeDisplay.textContent = `${value} px`;
  }

  // Synchro entre range et number
  sizePicker.addEventListener("input", () => {
    sizeNumber.value = sizePicker.value;
    updateSizeDisplay(sizePicker.value);
  });
  sizeNumber.addEventListener("input", () => {
    let val = parseFloat(sizeNumber.value);
    if (isNaN(val) || val < parseFloat(sizePicker.min)) val = parseFloat(sizePicker.min);
    else if (val > parseFloat(sizePicker.max)) val = parseFloat(sizePicker.max);
    sizeNumber.value = val;
    sizePicker.value = val;
    updateSizeDisplay(val);
  });

  // Gestion du mode dessin / texte / navigation
  modeToggle.addEventListener("click", () => {
    if (mode === "draw") {
      mode = "text";
      modeToggle.textContent = "Texte";
      modeToggle.classList.remove("active");
      modeToggle.setAttribute("aria-pressed", "false");
      canvas.style.cursor = "text";
      selectedTextIndex = null;
      redraw();
    } else if (mode === "text") {
      mode = "pan";
      modeToggle.textContent = "Navigation";
      modeToggle.setAttribute("aria-pressed", "false");
      modeToggle.classList.remove("active");
      canvas.style.cursor = "grab";
      selectedTextIndex = null;
      redraw();
    } else {
      mode = "draw";
      modeToggle.textContent = "Dessin";
      modeToggle.classList.add("active");
      modeToggle.setAttribute("aria-pressed", "true");
      canvas.style.cursor = "crosshair";
      selectedTextIndex = null;
      redraw();
    }
  });

  // Gestion du fond couleur
  bgColorPicker.addEventListener("input", () => {
    bgColor = bgColorPicker.value;
    redraw();
  });

  // Gestion image de fond
  bgImagePicker.addEventListener("change", e => {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => {
      bgImage = img;
      redraw();
    };
    img.onerror = () => alert("Erreur lors du chargement de l'image");
    img.src = URL.createObjectURL(file);
  });

  removeBgBtn.addEventListener("click", () => {
    bgImage = null;
    bgImagePicker.value = "";
    redraw();
  });

  // Undo
  undoBtn.addEventListener("click", () => {
    if (mode === "draw" && paths.length) {
      paths.pop();
      redraw();
    } else if (mode === "text" && texts.length) {
      texts.pop();
      redraw();
    }
  });

  // Clear
  clearBtn.addEventListener("click", () => {
    if (confirm("Effacer tout le dessin et le texte ?")) {
      paths = [];
      texts = [];
      bgImage = null;
      bgImagePicker.value = "";
      redraw();
    }
  });

  // Screenshot : image finale avec fond, paths, textes, titre
  screenshotBtn.addEventListener("click", () => {
    const exportCanvas = document.createElement("canvas");
    exportCanvas.width = canvas.width;
    exportCanvas.height = canvas.height;
    const exportCtx = exportCanvas.getContext("2d");

    // Fond couleur et image
    exportCtx.fillStyle = bgColor;
    exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
    if (bgImage) exportCtx.drawImage(bgImage, 0, 0, exportCanvas.width, exportCanvas.height);

    // Dessiner chemins
    for (const path of paths) {
      if (path.points.length < 2) continue;
      exportCtx.strokeStyle = path.color;
      exportCtx.lineWidth = path.size;
      exportCtx.lineCap = "round";
      exportCtx.lineJoin = "round";
      exportCtx.beginPath();
      exportCtx.moveTo(path.points[0].x, path.points[0].y);
      for (let i = 1; i < path.points.length; i++) {
        exportCtx.lineTo(path.points[i].x, path.points[i].y);
      }
      exportCtx.stroke();
    }

    // Dessiner textes
    for (const t of texts) {
      exportCtx.font = `${t.size}px Arial, sans-serif`;
      exportCtx.fillStyle = t.color;
      exportCtx.textBaseline = "top";
      exportCtx.fillText(t.text, t.x, t.y);
    }

    // Dessiner titre (au-dessus)
    const title = titleInput.value.trim();
    if (title) {
      exportCtx.font = "bold 24px Arial, sans-serif";
      exportCtx.fillStyle = "#222";
      exportCtx.textAlign = "center";
      exportCtx.fillText(title, exportCanvas.width / 2, 20);
    }

    // T√©l√©charger image
    exportCanvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = (title || "oeuvre") + ".png";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  });

  // Gestion du dessin et interaction avec la souris et tactile
  function onPointerDown(e) {
    e.preventDefault();

    if (mode === "draw") {
      const pos = screenToCanvas(e.clientX, e.clientY);
      startDrawing(pos.x, pos.y);
    } else if (mode === "text") {
      const pos = screenToCanvas(e.clientX, e.clientY);
      const idx = findTextAtPos(pos.x, pos.y);
      if (idx !== null) {
        selectedTextIndex = idx;
        isDraggingText = true;
        lastTouchOrMouse = { x: e.clientX, y: e.clientY };
        redraw();
      } else {
        addTextAtPos(pos.x, pos.y);
      }
    } else if (mode === "pan") {
      isPanning = true;
      lastTouchOrMouse = { x: e.clientX, y: e.clientY };
      canvas.style.cursor = "grabbing";
    }
  }

  function onPointerMove(e) {
    e.preventDefault();

    if (mode === "draw" && painting) {
      const pos = screenToCanvas(e.clientX, e.clientY);
      drawLine(pos.x, pos.y);
    } else if (mode === "text" && isDraggingText && selectedTextIndex !== null) {
      const dx = (e.clientX - lastTouchOrMouse.x) / scale;
      const dy = (e.clientY - lastTouchOrMouse.y) / scale;
      texts[selectedTextIndex].x += dx;
      texts[selectedTextIndex].y += dy;
      lastTouchOrMouse = { x: e.clientX, y: e.clientY };
      redraw();
    } else if (mode === "pan" && isPanning) {
      const dx = e.clientX - lastTouchOrMouse.x;
      const dy = e.clientY - lastTouchOrMouse.y;
      offsetX += dx;
      offsetY += dy;
      clampOffsets();
      lastTouchOrMouse = { x: e.clientX, y: e.clientY };
      redraw();
    }
  }

  function onPointerUp(e) {
    e.preventDefault();
    if (mode === "draw") {
      endDrawing();
    } else if (mode === "text") {
      isDraggingText = false;
    } else if (mode === "pan") {
      isPanning = false;
      canvas.style.cursor = "grab";
    }
  }

  // Zoom par molette, centr√© sur la souris
  function onWheel(e) {
    e.preventDefault();
    const wheelDelta = e.deltaY;
    const mouseX = e.clientX;
    const mouseY = e.clientY;
    const zoomFactor = 1.1;

    const prevScale = scale;
    if (wheelDelta < 0) {
      scale *= zoomFactor;
    } else {
      scale /= zoomFactor;
    }
    scale = Math.min(Math.max(scale, 0.1), 10);

    // Ajuster offset pour zoom centr√©
    const mx = (mouseX - offsetX) / prevScale;
    const my = (mouseY - offsetY) / prevScale;
    offsetX = mouseX - mx * scale;
    offsetY = mouseY - my * scale;

    clampOffsets();
    redraw();
  }

  // √âv√©nements pointer
  canvas.addEventListener("pointerdown", onPointerDown);
  canvas.addEventListener("pointermove", onPointerMove);
  canvas.addEventListener("pointerup", onPointerUp);
  canvas.addEventListener("pointercancel", onPointerUp);
  canvas.addEventListener("pointerleave", onPointerUp);
  canvas.addEventListener("wheel", onWheel, { passive: false });

  // Initialisation
  function init() {
    canvas.width = 600;
    canvas.height = 600;
    bgColor = bgColorPicker.value;
    scale = 1;
    offsetX = 0;
    offsetY = 0;
    redraw();
  }

  init();

})();
</script>
</body>
</html>
